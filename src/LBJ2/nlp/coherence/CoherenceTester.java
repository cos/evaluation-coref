package LBJ2.nlp.coherence;

import LBJ2.classify.*;
import LBJ2.learn.*;
import LBJ2.parse.Parser;
import LBJ2.nlp.coref.*;
import LBJ2.util.ClassUtils;


/**
  * This class may be used to produce a report of the accuracy of a coherence
  * classifier.
  *
  * <h4>Usage</h4>
  * <blockquote><pre>
  *   java LBJ2.nlp.coherence.CoherenceTester &lt;coherence classifier&gt; \
  *                                           &lt;labeled data&gt; \
  *                                           &lt;shuffle pair order&gt; \
  *                                           &lt;examples per document&gt; \
  *                                           &lt;shuffleIds&gt; \
  *                                           [&lt;verbosity&gt;]
  * </pre></blockquote>
  * or
  * <blockquote><pre>
  *   java LBJ2.nlp.coherence.CoherenceTester &lt;coherence classifier&gt; \
  *                                           &lt;labeled data&gt; \
  *                                           &lt;shuffle pair order&gt; \
  *                                           &lt;coref classifier&gt; \
  *                                           [&lt;verbosity&gt;]
  * </pre></blockquote>
  * or
  * <blockquote><pre>
  *   java LBJ2.nlp.coherence.CoherenceTester &lt;coherence classifier&gt; \
  *                                           &lt;labeled data&gt; \
  *                                           &lt;shuffle pair order&gt; \
  *                                           &lt;coref classifier 1&gt; \
  *                                           &lt;coref classifier 2&gt; \
  *                                           [&lt;verbosity&gt;]
  * </pre></blockquote>
  * or
  * <blockquote><pre>
  *   java LBJ2.nlp.coherence.CoherenceTester &lt;coherence classifier&gt; \
  *                                           &lt;labeled data&gt; \
  *                                           &lt;shuffle pair order&gt; \
  *                                           &lt;coref classifier&gt; \
  *                                           &lt;change probability&gt; \
  *                                           &lt;new ID probability&gt; \
  *                                           [&lt;verbosity&gt;]
  * </pre></blockquote>
  *
  * <h4>Input</h4>
  * <p> The first command line form above is used to produce document pairs in
  * which one of the documents is coref gold and the other is a shuffled
  * version of gold.  The second form creates pairs of gold labels and
  * predictions from the specified coref classifier (which can either be an
  * actual <code>Classifier</code> or a directory containing the predictions
  * of a classifier).  The third form takes two such classifiers, considering
  * whichever produces the higher <i>B<sup>3</sup></i> score to be the more
  * coherent.  The fourth command line form is similar to the third, except it
  * is assumed that one of the coref classifiers will be
  * <code>LBJ2.nlp.coref.PerturbedLabels</code>.
  *
  * <p> All forms start with the same three command line arguments.
  * <code>&lt;coherence classifier&gt;</code> is the fully qualified name of
  * the coherence classifier to test.  <code>&lt;labeled data&gt;</code> is
  * the name of a file containing names of ACE 2004 documents.
  * <code>&lt;shuffle pair order&gt;</code> must be exactly <code>true</code>
  * or <code>false</code>, and it controls whether the order of the documents
  * in each document-pair-example will be randomly permuted.
  *
  * <p> The rest of the command line arguments are particular to the forms
  * they appear in.  <code>&lt;examples per document&gt;</code> is the maximum
  * number of shuffled document pairs to create per original document.
  * <code>&lt;shuffleIds&gt;</code> will force entity IDs to be shuffled when
  * it appears explicitly as <code>true</code> and sentence ordering to be
  * shuffled when it appears explicitly as <code>false</code>.  The always
  * optional <code>&lt;verbosity&gt;</code> is an interger; the greater the
  * value, the more output is produced on <code>STDOUT</code>.
  * <code>&lt;coref classifier&gt;</code> can be one of two things.  First, it
  * can be the fully qualified name of a coref classifier that makes a
  * <code>true</code> or <code>false</code> prediction about a pair of
  * mentions stored in a {@link Mention}<code>[]</code>.  Second, it can be a
  * directory within which files labeled with predictions are stored.
  * <code>&lt;change probability&gt;</code> and <code>&lt;new ID
  * probability&gt;</code> are parameters for
  * <code>LBJ2.nlp.coref.PerturbedLabels</code>.
  *
  * <h4>Output</h4>
  * <p> The main output is generated by the
  * <code>LBJ2.classify.TestDiscrete</code> class.  See its online
  * documentation at
  * <a href="http://flake.cs.uiuc.edu/~rizzolo/LBJ2/library/LBJ2/classify/TestDiscrete.html">http://flake.cs.uiuc.edu/~rizzolo/LBJ2/library/LBJ2/classify/TestDiscrete.html</a>.
  * This output is generated regardless of the value of
  * <code>&lt;verbosity&gt;</code>.  When <code>&lt;verbosity&gt;</code> is
  * greater than 0, the name of each document followed by the coherence
  * classifier's unnormalized score on that document is printed.
 **/
public class CoherenceTester
{
  public static void main(String[] args)
  {
    String coherenceName = null;
    String filename = null;
    boolean shufflePairOrder = false;
    boolean automaticShuffling = false;
    boolean perturbed = false;
    String predictedDataRoot1 = null;
    String predictedDataRoot2 = null;
    int examplesPerDocument = 0;
    boolean shuffleIds = false;
    Classifier corefClassifier1 = null;
    Classifier corefClassifier2 = null;
    double changeProbability = 0;
    double newIDProbability = 0;
    int verbosity = 0;

    try
    {
      coherenceName = args[0];
      filename = args[1];
      shufflePairOrder = args[2].equals("true");
      automaticShuffling = Character.isDigit(args[3].charAt(0));

      if (automaticShuffling)
      {
        examplesPerDocument = Integer.parseInt(args[3]);
        if (examplesPerDocument < 1) throw new Exception();
        shuffleIds = args[4].equals("true");
        if (args.length == 6) verbosity = Integer.parseInt(args[5]);
        if (args.length > 6) throw new Exception();
      }
      else
      {
        String corefName = args[3];
        corefClassifier1 = ClassUtils.getClassifier(corefName, false);

        if (corefClassifier1 == null)
        {
          predictedDataRoot1 = args[3];
          corefName = null;
        }

        if (args.length == 5 && Character.isDigit(args[4].charAt(0)))
          verbosity = Integer.parseInt(args[4]);
        else if (args.length >= 5)
        {
          perturbed = true;

          try
          {
            changeProbability = Double.parseDouble(args[4]);
            newIDProbability = Double.parseDouble(args[5]);
          }
          catch (Exception e) { perturbed = false; }

          if (perturbed)
          {
            if (args.length == 7) verbosity = Integer.parseInt(args[6]);
            if (args.length > 7) throw new Exception();
          }
          else
          {
            corefName = args[4];
            corefClassifier2 = ClassUtils.getClassifier(corefName, false);

            if (corefClassifier2 == null)
            {
              predictedDataRoot2 = args[4];
              corefName = null;
            }

            if (args.length == 6) verbosity = Integer.parseInt(args[5]);
            if (args.length > 6) throw new Exception();
          }
        }
      }

      if (verbosity < 0) throw new Exception();
    }
    catch (Exception e)
    {
      System.err.println(
  "usage: java LBJ2.nlp.coherence.CoherenceTester <coherence classifier> \\\n"
+ "                                               <labeled data> \\\n"
+ "                                               <shuffle pair order> \\\n"
+ "                                               <examples per document> \\\n"
+ "                                               <shuffleIds> \\\n"
+ "                                               [<verbosity>]\n"
+ " or\n"
+ "       java LBJ2.nlp.coherence.CoherenceTester <coherence classifier> \\\n"
+ "                                               <labeled data> \\\n"
+ "                                               <shuffle pair order> \\\n"
+ "                                               <coref classifier> \\\n"
+ "                                               [<verbosity>]\n"
+ " or\n"
+ "       java LBJ2.nlp.coherence.CoherenceTester <coherence classifier> \\\n"
+ "                                               <labeled data> \\\n"
+ "                                               <shuffle pair order> \\\n"
+ "                                               <coref classifier 1> \\\n"
+ "                                               <coref classifier 2> \\\n"
+ "                                               [<verbosity>]\n"
+ " or\n"
+ "       java LBJ2.nlp.coherence.CoherenceTester <coherence classifier> \\\n"
+ "                                               <labeled data> \\\n"
+ "                                               <shuffle pair order> \\\n"
+ "                                               <coref classifier> \\\n"
+ "                                               <change probability> \\\n"
+ "                                               <new ID probability> \\\n"
+ "                                               [<verbosity>]");
      System.exit(1);
    }

    Learner cohere = ClassUtils.getLearner(coherenceName);
    Classifier labeler = new CoherenceLabel();
    TestDiscrete tester = new TestDiscrete();
    Parser parser = null;

    if (automaticShuffling)
      parser =
        new DocumentPairParser(new ACE2004DocumentParser(filename),
                               examplesPerDocument, shuffleIds,
                               shufflePairOrder);
    else if (predictedDataRoot2 == null && corefClassifier2 == null)
    {
      Parser p1 = null;
      Parser p2 = null;

      if (perturbed)
      {
        p1 =
          new PredictedDocumentParser(
              new ACE2004DocumentParser(filename),
              new PerturbedLabels());
        PerturbedLabels.setParameters(changeProbability, newIDProbability);
        labeler = new B3Label(verbosity);
      }
      else p1 = new ACE2004DocumentParser(filename);

      if (predictedDataRoot1 != null)
        p2 = new PrePredictedDocumentParser(predictedDataRoot1, filename);
      else
        p2 =
          new PredictedDocumentParser(
              new ACE2004DocumentParser(filename),
              corefClassifier1);

      parser = new DocumentPairParser(p1, p2, shufflePairOrder);
    }
    else
    {
      Parser p1 = null;
      Parser p2 = null;

      if (predictedDataRoot1 != null)
        p1 = new PrePredictedDocumentParser(predictedDataRoot1, filename);
      else
        p1 = new PredictedDocumentParser(new ACE2004DocumentParser(filename),
                                         corefClassifier1);

      if (predictedDataRoot2 != null)
        p2 = new PrePredictedDocumentParser(predictedDataRoot2, filename);
      else
        p2 = new PredictedDocumentParser(new ACE2004DocumentParser(filename),
                                         corefClassifier2);

      parser = new DocumentPairParser(p1, p2, shufflePairOrder);
      labeler = new B3Label(verbosity);
    }

    for (Object e = parser.next(); e != null; e = parser.next())
    {
      String label = labeler.discreteValue(e);
      String prediction = cohere.discreteValue(e);
      tester.reportPrediction(prediction, label);

      if (verbosity > 0)
      {
        Document[] pair = (Document[]) e;
        System.out.println(
            pair[0].getName() + ": " + cohere.scores(e).get(label));
        if (verbosity > 1)
          System.out.println(cohere.getExtractor().classify(e));
      }
    }

    tester.printPerformance(System.out);
  }
}

