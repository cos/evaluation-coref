package LBJ2.nlp.coherence;

import java.util.Random;
import LBJ2.parse.Parser;
import LBJ2.nlp.coref.Document;


/**
  * This parser can return pairs of documents constructed in several different
  * ways.  There are two major modes of operation.
  *
  * <ol>
  *   <li>
  *     Given a single <code>Parser</code> that returns {@link Document}s,
  *     this parser will return objects representing pairs of documents, the
  *     first of which contains sentences in their natural order, and the
  *     second of which contains a shuffling of the first document.  The
  *     shuffling can be either a permutation of the sentence order or a
  *     permutation of the mentions' entity ID assignments.
  *   <li>
  *     Given two <code>Parser</code>s that return {@link Document}s, this
  *     parser will assume the two return the same documents in the same
  *     order and form pairs accordingly.  The documents returned by the
  *     second parser will be considered "shuffled".
  * </ol>
 **/
public class DocumentPairParser implements Parser
{
  /**
    * Creates a seed for random number generation from a document.
    *
    * @param d  A document from which to generate a seed.
    * @return A seed for random number generation.
   **/
  private static int generateSeed(Document d)
  {
    return d.getName().hashCode();
  }


  /** The current document from which document pairs are extracted. */
  private Document doc;
  /** The maximum number of document pairs to extract from each document. */
  private int max;
  /**
    * The number of document pairs generated from the current document so far.
   **/
  private int index;
  /** A parser that provides {@link Document}s. */
  private Parser parser;
  /**
    * This random number generator is reseeded for each new document according
    * to the document's name, so that the shuffled document in the pair is
    * always shuffled in the same way, so long as the document's name is never
    * changed.
   **/
  private Random randomizer;
  /**
    * The shuffling strategy (described in more detail in the constructors'
    * documentation).
   **/
  private boolean shuffleIds;
  /** The mode of operation; either 1 or 2 as described above. */
  private int mode;
  /** A second parser for the second mode of operation described above. */
  private Parser shuffledParser;
  /**
    * Controls whether or not the documents in the pair are positioned
    * randomly.
   **/
  private boolean shufflePairOrder;


  /**
    * Initializing constructor.  Pairs will be generated by pairing a
    * naturally parsed document with the same document after shuffling its
    * sentences.
    *
    * @param p  A parser that provides {@link Document}s.
    * @param m  The maximum number of document pairs to extract from each
    *           document.
   **/
  public DocumentPairParser(Parser p, int m) { this(p, m, false); }

  /**
    * Initializing constructor.
    *
    * @param p  A parser that provides {@link Document}s.
    * @param m  The maximum number of document pairs to extract from each
    *           document.
    * @param s  The shuffling strategy.  If <code>true</code>, pairs will be
    *           generated by pairing a naturally parsed document with the same
    *           document after randomly reassigning the entity IDs to the
    *           mentions.  Otherwise, sentence order is shuffled.
   **/
  public DocumentPairParser(Parser p, int m, boolean s)
  {
    this(p, m, s, true);
  }

  /**
    * Initializing constructor.
    *
    * @param p  A parser that provides {@link Document}s.
    * @param m  The maximum number of document pairs to extract from each
    *           document.
    * @param s  The shuffling strategy.  If <code>true</code>, pairs will be
    *           generated by pairing a naturally parsed document with the same
    *           document after randomly reassigning the entity IDs to the
    *           mentions.  Otherwise, sentence order is shuffled.
    * @param o  Whether or not to shuffle the document pair order.
   **/
  public DocumentPairParser(Parser p, int m, boolean s, boolean o)
  {
    parser = p;
    doc = (Document) parser.next();
    if (doc != null) randomizer = new Random(generateSeed(doc));
    max = m;
    shuffleIds = s;
    shufflePairOrder = o;
    mode = 1;
  }

  /**
    * Initializing constructor.
    *
    * @param lp A parser returning documents which will be considered more
    *           coherent than the corresponding documents returned by the
    *           other parser.
    * @param sp The other parser.
   **/
  public DocumentPairParser(Parser lp, Parser sp) { this(lp, sp, true); }

  /**
    * Initializing constructor.
    *
    * @param lp A parser returning documents which will be considered more
    *           coherent than the corresponding documents returned by the
    *           other parser.
    * @param sp The other parser.
    * @param o  Whether or not to shuffle the document pair order.
   **/
  public DocumentPairParser(Parser lp, Parser sp, boolean o)
  {
    parser = lp;
    shuffledParser = sp;
    shufflePairOrder = o;
    mode = 2;
  }


  /** Retrieves the next pair of documents in a <code>Document[]</code>. */
  public Object next()
  {
    if (mode == 1)
    {
      while (doc != null
             && (index >= max
                 || index >= doc.sentences() * (doc.sentences() - 1) / 4))
      {
        doc = (Document) parser.next();
        //System.out.println(doc.getName());
        if (doc != null) randomizer = new Random(generateSeed(doc));
        index = 0;
      }

      if (doc == null) return null;
      //System.out.println(doc.getName() + ": " + index);
      ++index;
      Document shuffled = null;
      if (shuffleIds) shuffled = doc.shuffleEntityIds(randomizer);
      else shuffled = doc.shuffleSentences(randomizer);

      if (shufflePairOrder)
      {
        if (randomizer.nextBoolean())
          return new Document[]{ doc, shuffled };
      }
      else randomizer.nextBoolean();

      return new Document[]{ shuffled, doc };
    }

    Document moreCoherent = (Document) parser.next();
    if (moreCoherent == null) return null;
    moreCoherent.setMoreCoherent(true);
    Document lessCoherent = (Document) shuffledParser.next();
    lessCoherent.setMoreCoherent(false);
    if (shufflePairOrder
        && new Random(moreCoherent.getName().hashCode()).nextBoolean())
      return new Document[]{ moreCoherent, lessCoherent };
    return new Document[]{ lessCoherent, moreCoherent };
  }


  public void reset()
  {
    parser.reset();

    if (mode == 1)
    {
      doc = (Document) parser.next();
      if (doc != null) randomizer = new Random(generateSeed(doc));
    }
    else shuffledParser.reset();
  }
}

